C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\AuthorizationServerApplication.java
package mango.security.authorizationServer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthorizationServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(AuthorizationServerApplication.class, args);
	}

}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\config\AuthorizationServerConfig.java
package mango.security.authorizationServer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.oauth2.server.authorization.client.JdbcRegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;

import java.time.Instant;
import java.util.UUID;

@Configuration
public class AuthorizationServerConfig {
    @Bean
    public RegisteredClientRepository registeredClientRepository(JdbcTemplate jdbcTemplate, PasswordEncoder passwordEncoder) {
        JdbcRegisteredClientRepository repository = new JdbcRegisteredClientRepository(jdbcTemplate);
        String clientId = "mango-client";
        if(repository.findByClientId(clientId) == null) {
            RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())
                    .clientId(clientId)
                    .clientSecret(passwordEncoder.encode("mango-secret"))
                    .clientIdIssuedAt(Instant.now())
                    .clientName("Mango Local Client")
                    .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                    .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                    .redirectUri("http://localhost:3000/login/oauth2/code/mango-client")
                    .scope("read")
                    .scope("write")
                    .build();
            repository.save(registeredClient);
        }
        return repository;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
        // 단편적으로 봤을때는 BCrypotPasswordEncoder를 사용하는 것과 동일
        // 하지만 향후 확장성을 고려하거나 Spring 권장 방식을 따르기에
        // PasswordEncoderFactories.createDelegatingPasswordEncoder()를 사용하는 것이 좋다.
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\config\JwkConfig.java
package mango.security.authorizationServer.config;

// java security : 키 생성 관련련
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.UUID;

// spring security : jwt 발급용용
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;

// Nimbus JOSE + JWT - JWK 처리 관련
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;

/**
 * JWK란?
 * - JWK (JSON Web Key)는 암호화 키를 표현하는 JSON 데이터 구조입니다.
 * - RFC 7517에 정의되어 있으며, 공개 키 혹은 비대칭/대칭 키에 대한 메타 정보를 포함할 수 있습니다.
 * - JWK는 키 타입(kty), 키 ID(kid), 공개 키 또는 비공개 키의 구성 요소(n, e, d 등)를 명시합니다.
 * - 예를 들어 RSA 키의 경우 다음 필드를 포함할 수 있습니다:
 *     - "kty": 키 타입 (예: "RSA")
 *     - "n": modulus (base64url 인코딩된 값)
 *     - "e": exponent (base64url 인코딩된 값)
 *     - "d": private exponent (optional, 서명/복호화용)
 *
 * JWK Set이란?
 * - 여러 개의 JWK를 포함하는 JSON 객체 구조입니다.
 * - "keys": [ ... ] 배열 형태로 구성됩니다.
 *
 * @Configuration
 * public class JwkConfig
 * 
 * @Bean
 * public JWKSource<SecurityContext> jwkSource()
 * - JWT 서명을 위한 JWK(RSAKey)를 생성하고, 이를 기반으로 JWKSet을 구성합니다.
 * - JWKSource는 JWT 인코더가 서명 시 사용할 키를 동적으로 선택할 수 있도록 도와줍니다.
 * - NimbusJwtEncoder와 연동되어 JWT 발급 시 서명 키로 사용됩니다.
 * 
 * private RSAKey generateRSAKey()
 * - 2048비트 RSA 키 쌍을 생성하고 이를 기반으로 Nimbus의 RSAKey 객체를 구성합니다.
 * - RSAKey.Builder를 통해 공개키/개인키, 키 ID(kid)를 설정합니다.
 * - 이렇게 생성된 RSAKey는 JWK 표준 형식으로 자동 변환됩니다.
 * 
 * @Bean
 * public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource)
 * - Spring Security의 NimbusJwtEncoder에 JWKSource를 주입하여 JWT 서명을 처리합니다.
 * - JWT를 인코딩(발급)할 때 위에서 생성된 RSA 개인 키로 서명합니다.
 * 
 * 이 구성 클래스는 OAuth2 Authorization Server에서 JWT 기반 토큰을 발급할 때,
 * 그 토큰에 서명할 RSA 키를 JWK 형식으로 관리하고 외부에 노출할 수 있도록 준비합니다.
 * 클라이언트는 `/oauth2/jwks` 또는 비슷한 경로로 JWKSet을 조회하여 토큰 검증 시 사용 가능한 공개 키를 획득할 수 있습니다.
 */


@Configuration
public class JwkConfig {

    // JWT 서명용 RSA 키를 포함한 JWKSource Bean 등록
    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        RSAKey rsakey = generateRSAKey(); // 아래에서 생성
        JWKSet jwkSet = new JWKSet(rsakey); // JWK 세트 생성
        return (jwkSelector, securityContext) -> jwkSelector.select(jwkSet);
    }

    // RSA 키 생성 후 Nimbus RSAKey 객체로 반환
    private RSAKey generateRSAKey() {
        try{
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            KeyPair keyPair = keyPairGenerator.generateKeyPair();
            RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();

            return new RSAKey.Builder(publicKey)
                    .privateKey(privateKey)
                    .keyID(UUID.randomUUID().toString())
                    .build();
        } catch (Exception ex) {
            throw new RuntimeException("RSA 키 생성 실패", ex);
        }
    }
    @Bean
    public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\config\OAuth2TokenCustomizerConfig.java
package mango.security.authorizationServer.config;

import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.service.TokenPersistenceService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext;
import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer;

import java.time.Instant;
import java.util.UUID;

@Configuration
public class OAuth2TokenCustomizerConfig {
    @Value("${token.refreshToken.ttl}")
    private long rereshTokenTtl;

    private final TokenPersistenceService tokenPersistenceService;

    public OAuth2TokenCustomizerConfig(TokenPersistenceService tokenPersistenceService) {
        this.tokenPersistenceService = tokenPersistenceService;
    }

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            // OAuth2AuthorizationServerConfigurer 내에서 access token 발급 시 이 커스터마이저가 호출됩니다.
            if ("access_token".equals(context.getTokenType().getValue())) {
                JwtClaimsSet.Builder claimsBuilder = context.getClaims();
                JwtClaimsSet claims = claimsBuilder.build();
                Instant issuedAt = claims.getIssuedAt();
                Instant expiresAt = claims.getExpiresAt();

//                String accessTokenValue = context.getTokenValue();
                String accessTokenValue;
                if (claims.getClaim("jti") != null) {
                    accessTokenValue = claims.getClaim("jti").toString();
                } else {
                    accessTokenValue = UUID.randomUUID().toString();
                    claimsBuilder.claim("jti", accessTokenValue);
                }
                String principalName = context.getPrincipal().getName();
                String clientId = context.getRegisteredClient().getClientId();

                // Access token 정보 DTO 생성
                StoredTokenDto accessTokenDto = new StoredTokenDto(
                        accessTokenValue,
                        principalName,
                        clientId,
                        "access",
                        issuedAt,
                        expiresAt
                );

                String refreshTokenValue = UUID.randomUUID().toString();
                // refresh token 발급 시점과 만료 시간은 정책에 따라 정합니다.
                Instant refreshIssuedAt = Instant.now();
                // refreshTokenTtl는 일(day) 단위로 설정됨 (예: 7일)
                long ttl = rereshTokenTtl * 60 * 60 * 24;
                Instant refreshExpiresAt = refreshIssuedAt.plusSeconds(ttl); // 예: 1일
                StoredTokenDto refreshTokenDto = new StoredTokenDto(
                        refreshTokenValue,
                        principalName,
                        clientId,
                        "refresh",
                        refreshIssuedAt,
                        refreshExpiresAt
                );

                // 토큰 쌍 저장
                tokenPersistenceService.persistTokenPair(accessTokenDto, refreshTokenDto);
            }
        };
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\config\RedisConfig.java
package mango.security.authorizationServer.config;

import mango.security.authorizationServer.exception.RedisException;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
public class RedisConfig {
    @Value("${spring.data.redis.host}")
    private String host;

    @Value("${spring.data.redis.port}")
    private int port;

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        try{
            RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(host, port);
            LettuceClientConfiguration clientConfiguration = LettuceClientConfiguration.builder()
                    .commandTimeout(Duration.ofSeconds(2))
                    .shutdownTimeout(Duration.ofMillis(100))
                    .build();
            return new LettuceConnectionFactory(redisStandaloneConfiguration, clientConfiguration);
        } catch (Exception e) {
            throw new RedisException(ApiResponseType.REDIS_CONNECTION_FAILED, e);
        }
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        var template = new RedisTemplate<String, Object>();
        template.setConnectionFactory(redisConnectionFactory);

        // Key: String, Value: JSON 직렬화
        var keySerializer = new StringRedisSerializer();
        var valueSerializer = new GenericJackson2JsonRedisSerializer();

        template.setKeySerializer(keySerializer);
        template.setValueSerializer(valueSerializer);
        template.setHashKeySerializer(keySerializer);
        template.setHashValueSerializer(valueSerializer);

        template.afterPropertiesSet();
        return template;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\config\SecurityConfig.java
package mango.security.authorizationServer.config;

import mango.security.authorizationServer.filter.PreflightClientCheckFilter;
import mango.security.authorizationServer.repository.RegisteredClientJpaRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.MediaType;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer;
import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint;
import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder passwordEncoder) {
        // 테스트용 사용자 추가 (username: test, password: test123)
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("test")
                .password(passwordEncoder.encode("test1234"))
                .roles("USER")
                .build());
        return manager;
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder()
                .issuer("http://localhost:9000")
                .build();
    }

    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http,
                                                                    RegisteredClientJpaRepository registeredClientJpaRepository) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer();
        http
            .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
            .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/login").permitAll()
                    .anyRequest().authenticated()
            )
            .apply(authorizationServerConfigurer);

        // CSRF 보호는 OAuth2 엔드포인트에 대해 비활성화
        http.csrf(csrf -> csrf.ignoringRequestMatchers(authorizationServerConfigurer.getEndpointsMatcher()));

        // 인증되지 않은 HTML 요청은 /login 페이지로 리다이렉션
        http.exceptionHandling(exceptions -> exceptions.defaultAuthenticationEntryPointFor(
                new LoginUrlAuthenticationEntryPoint("/login"),
                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
        ));

        // 등록된 클라이언트 체크 필터 추가 (Preflight 요청 등)
        http.addFilterBefore(new PreflightClientCheckFilter(registeredClientJpaRepository), 
                            org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.class);

        // JWT 리소스 서버 기능 (옵션)
        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));

        return http.build();
    }

    @Bean
    @Order(Ordered.LOWEST_PRECEDENCE)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                    .anyRequest().permitAll()
            )
            .formLogin(form -> form
                    .permitAll()
            )
            .logout(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable());

        return http.build();
    }
}

C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\controller\ConsentController.java
package mango.security.authorizationServer.controller;

import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.dto.ConsentRequestDto;
import mango.security.authorizationServer.service.ConsentService;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/oauth2/consent")
public class ConsentController {
    private final ConsentService consentService;

    public ConsentController(ConsentService consentService) {
        this.consentService = consentService;
    }

    @GetMapping
    public BaseResponseDto<Object> consentInfo(ConsentRequestDto reqDto) {
        var data = consentService.extractConsentInfo(reqDto);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, data);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\controller\LogoutController.java
package mango.security.authorizationServer.controller;

import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.service.TokenRedisService;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/logout")
public class LogoutController {

    private final TokenRedisService tokenRedisService;

    public LogoutController(TokenRedisService tokenRedisService) {
        this.tokenRedisService = tokenRedisService;
    }

    /**
     * 로그아웃 시 access token과 refresh token을 철회(삭제) 처리하는 API
     * 클라이언트는 accessToken, refreshToken 값을 전달해야 합니다.
     */
    @DeleteMapping
    public BaseResponseDto<Object> logout(String accessToken, String refreshToken) {
        tokenRedisService.deleteTokenPair(accessToken, refreshToken);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, "로그아웃 및 토큰 철회가 완료되었습니다.");
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\controller\TokenDebugController.java
package mango.security.authorizationServer.controller;

import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.dto.TokenPairDto;
import mango.security.authorizationServer.service.TokenRedisService;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/debug/token")
public class TokenDebugController {

    private final TokenRedisService tokenRedisService;

    public TokenDebugController(TokenRedisService tokenRedisService) {
        this.tokenRedisService = tokenRedisService;
    }

    @PostMapping("/save")
    public BaseResponseDto<Object> saveToken(@RequestParam("type") String type) {
        Instant now = Instant.now();
        StoredTokenDto token = new StoredTokenDto(
                UUID.randomUUID().toString(),
                "user@example.com",
                "mango-client",
                type,
                now,
                now.plusSeconds(type.equals("access") ? 600 : 86400)
        );
        tokenRedisService.saveToken(token);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, token);
    }

    @PostMapping("/save-pair")
    public BaseResponseDto<Object> saveTokenPair() {
        Instant now = Instant.now();
        String access = UUID.randomUUID().toString();
        String refresh = UUID.randomUUID().toString();

        StoredTokenDto accessToken = new StoredTokenDto(
                access, "user@example.com", "mango-client", "access", now, now.plusSeconds(600));
        StoredTokenDto refreshToken = new StoredTokenDto(
                refresh, "user@example.com", "mango-client", "refresh", now, now.plusSeconds(86400));

        tokenRedisService.saveTokenPair(new TokenPairDto(accessToken, refreshToken));

        return BaseResponseDto.of(ApiResponseType.SUCCESS, Map.of(
                "accessToken", access,
                "refreshToken", refresh
        ));
    }

    @GetMapping("/get")
    public BaseResponseDto<Object> getToken(@RequestParam("type") String type, @RequestParam("value") String value) {
        var token = tokenRedisService.getToken(value, type);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, token);
    }

    @DeleteMapping("/delete")
    public BaseResponseDto<Object> deleteToken(@RequestParam("type") String type, @RequestParam("value") String value) {
        tokenRedisService.deleteToken(value, type);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, "삭제됨");
    }

    @DeleteMapping("/delete-pair")
    public BaseResponseDto<Object> deletePair(@RequestParam("access") String access, @RequestParam("refresh") String refresh) {
        tokenRedisService.deleteTokenPair(access, refresh);
        return BaseResponseDto.of(ApiResponseType.SUCCESS, "쌍 삭제 완료");
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\dto\BaseResponseDto.java
package mango.security.authorizationServer.dto;

import mango.security.authorizationServer.type.ApiResponseType;

public record BaseResponseDto<T>(String status, String message, T data) {
    public static <T> BaseResponseDto<T> of(ApiResponseType type, T data) {
        return new BaseResponseDto<>(type.getStatus(), type.getMessage(), data);
    }

    public static <T> BaseResponseDto<T> withMessage(ApiResponseType type, String message) {
        return new BaseResponseDto<>(type.getStatus(), message, null);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\dto\ConsentConfirmRequestDto.java
package mango.security.authorizationServer.dto;

public record ConsentConfirmRequestDto(
        String client_id,
        String principal_name,
        String scope // "read write"
) {}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\dto\ConsentRequestDto.java
package mango.security.authorizationServer.dto;

public record ConsentRequestDto(
        String client_id,
        String scope,
        String redirect_uri
) {}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\dto\StoredTokenDto.java
package mango.security.authorizationServer.dto;

import java.io.Serializable;
import java.time.Instant;

public record StoredTokenDto(
        String tokenValue,
        String principalName,
        String clientId,
        String tokenType, // "access" or "refresh"
        Instant issuedAt,
        Instant expiresAt
) implements Serializable {}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\dto\TokenPairDto.java
package mango.security.authorizationServer.dto;

import java.io.Serializable;

public record TokenPairDto(
        StoredTokenDto accessToken,
        StoredTokenDto refreshToken
) implements Serializable {}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\entity\AuthorizationConsentId.java
package mango.security.authorizationServer.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import jakarta.persistence.Table;
import lombok.Getter;

import java.io.Serializable;
import java.util.Objects;

@Embeddable
@Getter
@Table(name = "authorization_consent")
public class AuthorizationConsentId implements Serializable {
    @Column(name="registered_client_id", length = 100, nullable = false)
    private String registeredClientId;

    @Column(name="principal_name", length = 200, nullable = false)
    private String principalName;

    // 기본 생성자 & equals, hashCode 필수!
    public AuthorizationConsentId() {}

    public AuthorizationConsentId(String registeredClientId, String principalName) {
        this.registeredClientId = registeredClientId;
        this.principalName = principalName;
    }

    public String getRegisteredClientId() {
        return registeredClientId;
    }

    public String getPrincipalName() {
        return principalName;
    }

    // equals, hashCode 필수!
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof AuthorizationConsentId that)) return false;
        return Objects.equals(registeredClientId, that.registeredClientId)
                && Objects.equals(principalName, that.principalName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(registeredClientId, principalName);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\entity\OAuth2AuthorizationConsentEntity.java
package mango.security.authorizationServer.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Setter
@Getter
@Entity
@Table(name = "oauth2_authorization_consent")
public class OAuth2AuthorizationConsentEntity {

    @EmbeddedId
    private AuthorizationConsentId id;

    @Column(name = "authorities", nullable = false, length = 1000)
    private String authorities;

    // 추가 필드의 getter/setter
    // 추가 필드들
    @Column(name = "refresh_token_value")
    private String refreshTokenValue;

    @Column(name = "client_id")
    private String clientId;

    @Column(name = "refresh_token_issued_at")
    private Instant refreshTokenIssuedAt;

    @Column(name = "refresh_token_expires_at")
    private Instant refreshTokenExpiresAt;

    public OAuth2AuthorizationConsentEntity() {}

    public OAuth2AuthorizationConsentEntity(AuthorizationConsentId id, String authorities) {
        this.id = id;
        this.authorities = authorities;
    }

}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\entity\OAuth2AuthorizationEntity.java
package mango.security.authorizationServer.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;

@Entity
@Table(name = "oauth2_authorization")
public class OAuth2AuthorizationEntity {

    @Id
    private String id;

    @Column(name = "client_id", nullable = false)
    private String clientId;

    @Column(name = "principal_name", nullable = false)
    private String principalName;

    @Column(name = "refresh_token_value", columnDefinition = "text")
    private String refreshTokenValue;

    @Column(name = "refresh_token_issued_at")
    private Instant refreshTokenIssuedAt;

    @Column(name = "refresh_token_expires_at")
    private Instant refreshTokenExpiresAt;

    public OAuth2AuthorizationEntity() {}

    // getters and setters

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public String getPrincipalName() {
        return principalName;
    }

    public void setPrincipalName(String principalName) {
        this.principalName = principalName;
    }

    public String getRefreshTokenValue() {
        return refreshTokenValue;
    }

    public void setRefreshTokenValue(String refreshTokenValue) {
        this.refreshTokenValue = refreshTokenValue;
    }

    public Instant getRefreshTokenIssuedAt() {
        return refreshTokenIssuedAt;
    }

    public void setRefreshTokenIssuedAt(Instant refreshTokenIssuedAt) {
        this.refreshTokenIssuedAt = refreshTokenIssuedAt;
    }

    public Instant getRefreshTokenExpiresAt() {
        return refreshTokenExpiresAt;
    }

    public void setRefreshTokenExpiresAt(Instant refreshTokenExpiresAt) {
        this.refreshTokenExpiresAt = refreshTokenExpiresAt;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\entity\RegisteredClientEntity.java
package mango.security.authorizationServer.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;

@Entity
@Getter @Setter
@Table(name = "oauth2_registered_client")
public class RegisteredClientEntity {

    @Id
    private String id;

    @Column(name = "client_id", nullable = false)
    private String clientId;

    @Column(name = "client_secret")
    private String clientSecret;

    @Column(name = "client_id_issued_at", nullable = false)
    private Instant clientIdIssuedAt;

    @Column(name = "client_secret_expires_at")
    private Instant clientSecretExpiresAt;

    @Column(name = "client_name", nullable = false)
    private String clientName;

    @Column(name = "client_authentication_methods", nullable = false)
    private String clientAuthenticationMethods;

    @Column(name = "authorization_grant_types", nullable = false)
    private String authorizationGrantTypes;

    @Column(name = "redirect_uris")
    private String redirectUris;

    @Column(name = "post_logout_redirect_uris")
    private String postLogoutRedirectUris;

    @Column(name = "scopes", nullable = false)
    private String scopes;

    @Column(name = "client_settings", nullable = false, length = 2000)
    private String clientSettings;

    @Column(name = "token_settings", nullable = false, length = 2000)
    private String tokenSettings;
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\exception\AuthException.java
package mango.security.authorizationServer.exception;

import mango.security.authorizationServer.type.ApiResponseType;

public class AuthException extends RuntimeException {
    private final ApiResponseType responseType;

    public AuthException(ApiResponseType responseType, String message) {
        super(message);
        this.responseType = responseType;
    }

    public AuthException(ApiResponseType responseType) {
        super(responseType.getMessage());
        this.responseType = responseType;
    }

    public ApiResponseType getResponseType() {
        return responseType;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\exception\GlobalExceptionHandler.java
package mango.security.authorizationServer.exception;

import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {

    // 모든 예외 처리 (최종 캐치)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<BaseResponseDto<Object>> handleAllExceptions(Exception ex) {
        // 로깅 등 추가 작업 가능
        return new ResponseEntity<>(BaseResponseDto.withMessage(ApiResponseType.ERROR, ex.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleAuthenticationException(AuthenticationException ex) {
        return new ResponseEntity<>(BaseResponseDto.withMessage(ApiResponseType.UNAUTHORIZED, ex.getMessage()), HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(OAuth2AuthenticationException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleOAuth2AuthenticationException(OAuth2AuthenticationException ex) {
        return new ResponseEntity<>(BaseResponseDto.withMessage(ApiResponseType.UNAUTHORIZED, ex.getMessage()), HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleAccessDeniedException(AccessDeniedException ex) {
        return new ResponseEntity<>(BaseResponseDto.withMessage(ApiResponseType.FORBIDDEN, ex.getMessage()), HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(AuthException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleAuthException(AuthException ex) {
        return new ResponseEntity<>(BaseResponseDto.withMessage(ex.getResponseType(), ex.getMessage()), HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(RedisException.class)
    public ResponseEntity<BaseResponseDto<Object>> handleRedisException(RedisException ex) {
        return new ResponseEntity<>(
                BaseResponseDto.withMessage(ex.getResponseType(), ex.getMessage()),
                HttpStatus.SERVICE_UNAVAILABLE
        );
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\exception\RedisException.java
package mango.security.authorizationServer.exception;

import mango.security.authorizationServer.type.ApiResponseType;

public class RedisException extends RuntimeException {
    private final ApiResponseType responseType;

    public RedisException(ApiResponseType responseType, Throwable cause) {
        super(responseType.getMessage(), cause);
        this.responseType = responseType;
    }

    public ApiResponseType getResponseType() {
        return responseType;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\filter\PreflightClientCheckFilter.java
package mango.security.authorizationServer.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.repository.RegisteredClientJpaRepository;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class PreflightClientCheckFilter extends OncePerRequestFilter {
    private final RegisteredClientJpaRepository clientRepository;

    public PreflightClientCheckFilter(RegisteredClientJpaRepository clientRepository) {
        this.clientRepository = clientRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain filterChain) throws ServletException, IOException {
        if("OPTIONS".equalsIgnoreCase(req.getMethod())) {
            String clientId = req.getHeader("client-id");
            if(clientId != null && !isClientIdRegistered(clientId)){
                BaseResponseDto<Object> responseDto = BaseResponseDto.withMessage(ApiResponseType.FORBIDDEN, null);
                res.setStatus(Integer.parseInt(ApiResponseType.FORBIDDEN.getStatus()));
                res.setContentType("application/json;charset=UTF-8");
                res.getWriter().write(new ObjectMapper().writeValueAsString(responseDto));
                return;
            }

        }
        filterChain.doFilter(req, res);
    }

    private boolean isClientIdRegistered(String clientId) {
        long count = clientRepository.countByClientId(clientId);
        return count > 0;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\repository\AuthorizationConsentRepository.java
package mango.security.authorizationServer.repository;

import mango.security.authorizationServer.entity.AuthorizationConsentId;
import mango.security.authorizationServer.entity.OAuth2AuthorizationConsentEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AuthorizationConsentRepository
        extends JpaRepository<OAuth2AuthorizationConsentEntity, AuthorizationConsentId> {

    Optional<OAuth2AuthorizationConsentEntity> findById(AuthorizationConsentId id);
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\repository\OAuth2AuthorizationRepository.java
package mango.security.authorizationServer.repository;

import mango.security.authorizationServer.entity.OAuth2AuthorizationEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface OAuth2AuthorizationRepository extends JpaRepository<OAuth2AuthorizationEntity, String> {
    Optional<OAuth2AuthorizationEntity> findByRefreshTokenValue(String refreshTokenValue);
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\repository\RegisteredClientJpaRepository.java
package mango.security.authorizationServer.repository;

import mango.security.authorizationServer.entity.RegisteredClientEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface RegisteredClientJpaRepository extends JpaRepository<RegisteredClientEntity, String> {
    Optional<RegisteredClientEntity> findByClientId(String clientId);
    long countByClientId(String clientId);
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\security\CustomAccessDeniedHandler.java
package mango.security.authorizationServer.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        BaseResponseDto<Object> errorResponse = BaseResponseDto.withMessage(ApiResponseType.FORBIDDEN, null);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(Integer.parseInt(ApiResponseType.FORBIDDEN.getStatus()));
        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}

C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\security\CustomAuthenticationEntryPoint.java
package mango.security.authorizationServer.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import mango.security.authorizationServer.dto.BaseResponseDto;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        ApiResponseType responseType;
        // 토큰 만료 관련 예외 처리
        if (authException.getCause() != null &&
                authException.getCause().getMessage() != null &&
                authException.getCause().getMessage().toLowerCase().contains("expired")) {
            responseType = ApiResponseType.OUTDATED_TOKEN;
        } else {
            responseType = ApiResponseType.INVALID_TOKEN;
        }
        response.setCharacterEncoding("UTF-8");
        BaseResponseDto<Object> errorResponse = BaseResponseDto.withMessage(responseType, authException.getMessage());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(Integer.parseInt(responseType.getStatus()));
        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\AuthorizationConsentService.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.ConsentConfirmRequestDto;
import mango.security.authorizationServer.entity.AuthorizationConsentId;
import mango.security.authorizationServer.entity.OAuth2AuthorizationConsentEntity;
import mango.security.authorizationServer.exception.AuthException;
import mango.security.authorizationServer.repository.AuthorizationConsentRepository;
import mango.security.authorizationServer.repository.RegisteredClientJpaRepository;
import mango.security.authorizationServer.type.ApiResponseType;
import mango.security.authorizationServer.util.Assert;
import org.springframework.stereotype.Service;

@Service
public class AuthorizationConsentService {
    private final AuthorizationConsentRepository authorizationConsentRepository;
    private final RegisteredClientJpaRepository registeredClientJpaRepository;

    public AuthorizationConsentService(AuthorizationConsentRepository authorizationConsentRepository,
            RegisteredClientJpaRepository registeredClientJpaRepository) {
        this.authorizationConsentRepository = authorizationConsentRepository;
        this.registeredClientJpaRepository = registeredClientJpaRepository;
    }

    public void confirmConsent(ConsentConfirmRequestDto dto){
        // 필수값 검증
        Assert.notBlank(dto.client_id(), ApiResponseType.CLIENT_ID_REQUIRED);
        Assert.notBlank(dto.principal_name(), ApiResponseType.PRINCIPAL_NAME_REQUIRED);
        Assert.notBlank(dto.scope(), ApiResponseType.SCOPE_REQUIRED);

        // 클라이언트 유효성 확인
        boolean exists =registeredClientJpaRepository.existsById(dto.client_id());
        if(!exists){
            throw new AuthException(ApiResponseType.CLIENT_NOT_FOUND);
        }

        // 이미 동의한 경우 예외
        AuthorizationConsentId id = new AuthorizationConsentId(dto.client_id(), dto.principal_name());
        if (authorizationConsentRepository.findById(id).isPresent()){
            throw new AuthException(ApiResponseType.CLIENT_ALREADY_CONSENTED);
        }

        // 동의 정보 저장
        OAuth2AuthorizationConsentEntity entity = new OAuth2AuthorizationConsentEntity(
                id,
                dto.scope() // read, write
        );

        authorizationConsentRepository.save(entity);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\ConsentService.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.ConsentRequestDto;
import mango.security.authorizationServer.exception.AuthException;
import mango.security.authorizationServer.repository.RegisteredClientJpaRepository;
import mango.security.authorizationServer.type.ApiResponseType;
import mango.security.authorizationServer.util.Assert;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class ConsentService {

    private final RegisteredClientJpaRepository clientRepository;

    public ConsentService(RegisteredClientJpaRepository clientRepository) {
        this.clientRepository = clientRepository;
    }

    public Map<String, String> extractConsentInfo(ConsentRequestDto dto) {
        Assert.notBlank(dto.client_id(), ApiResponseType.INVALID_REQUEST);
        Assert.notBlank(dto.scope(), ApiResponseType.INVALID_REQUEST);

        var client = clientRepository.findByClientId(dto.client_id())
                .orElseThrow(() -> new AuthException(ApiResponseType.CLIENT_NOT_FOUND));

        return Map.of(
                "clientName", client.getClientName(),
                "requestedScope", dto.scope(),
                "redirectedUri", dto.redirect_uri()
        );
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\RefreshTokenService.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.StoredTokenDto;

public interface RefreshTokenService {
    StoredTokenDto getRefreshToken(String refreshTokenValue);
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\RefreshTokenServiceImpl.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.entity.OAuth2AuthorizationEntity;
import mango.security.authorizationServer.exception.AuthException;
import mango.security.authorizationServer.repository.OAuth2AuthorizationRepository;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class RefreshTokenServiceImpl implements RefreshTokenService {

    private final TokenRedisService tokenRedisService;
    private final OAuth2AuthorizationRepository authorizationRepository;

    public RefreshTokenServiceImpl(TokenRedisService tokenRedisService,
                                OAuth2AuthorizationRepository authorizationRepository) {
        this.tokenRedisService = tokenRedisService;
        this.authorizationRepository = authorizationRepository;
    }

    @Override
    public StoredTokenDto getRefreshToken(String refreshTokenValue) {
        try {
            // 먼저 Redis에서 조회
            return tokenRedisService.getToken(refreshTokenValue, "refresh_token");
        } catch (AuthException ex) {
            // Redis에 없으면 DB 조회
            Optional<OAuth2AuthorizationEntity> tmp = authorizationRepository.findByRefreshTokenValue(refreshTokenValue);
            if (tmp.isEmpty()) {
                throw new AuthException(ApiResponseType.INVALID_TOKEN, "DB에 refresh token이 존재하지 않습니다.");
            }
            OAuth2AuthorizationEntity entity = tmp.get();
            StoredTokenDto storedTokenDto = convertEntityToStoredToken(entity);
            // DB에서 조회한 토큰을 Redis에 재저장 (선택 사항)
            tokenRedisService.saveToken(storedTokenDto);
            return storedTokenDto;
        }
    }

    private StoredTokenDto convertEntityToStoredToken(OAuth2AuthorizationEntity entity) {
        return new StoredTokenDto(
                entity.getRefreshTokenValue(),
                entity.getPrincipalName(),
                entity.getClientId(),
                "refresh",
                entity.getRefreshTokenIssuedAt(),
                entity.getRefreshTokenExpiresAt()
        );
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\TokenPersistenceService.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.dto.TokenPairDto;
import org.springframework.stereotype.Service;

@Service
public class TokenPersistenceService {
    private final TokenRedisService tokenRedisService;

    public TokenPersistenceService(TokenRedisService tokenRedisService) {
        this.tokenRedisService = tokenRedisService;
    }

    public void persistTokenPair(StoredTokenDto accessToken, StoredTokenDto refreshToken) {
        if (refreshToken != null) {
            TokenPairDto pair = new TokenPairDto(accessToken, refreshToken);
            tokenRedisService.saveTokenPair(pair);
        } else {
            // refresh token이 없는 경우 단일 저장
            tokenRedisService.saveToken(accessToken);
        }
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\TokenRedisService.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.dto.TokenPairDto;

public interface TokenRedisService {
    void saveToken(StoredTokenDto token);
    StoredTokenDto getToken(String tokenValue, String tokenType);
    void deleteToken(String tokenValue, String tokenType);

    void saveTokenPair(TokenPairDto pair);
    void deleteTokenPair(String accessTokenValue, String refreshTokenValue);
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\service\TokenRedisServiceImpl.java
package mango.security.authorizationServer.service;

import mango.security.authorizationServer.dto.StoredTokenDto;
import mango.security.authorizationServer.dto.TokenPairDto;
import mango.security.authorizationServer.exception.AuthException;
import mango.security.authorizationServer.type.ApiResponseType;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
public class TokenRedisServiceImpl implements TokenRedisService {

    private final RedisTemplate<String, Object> redisTemplate;

    public TokenRedisServiceImpl(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    private String buildKey(String tokenType, String tokenValue) {
        return tokenType + "_token:" + tokenValue;
    }

    @Override
    public void saveToken(StoredTokenDto token) {
        String key = buildKey(token.tokenType(), token.tokenValue());
        Duration ttl = Duration.between(token.issuedAt(), token.expiresAt());
        redisTemplate.opsForValue().set(key, token, ttl);
    }

    @Override
    public StoredTokenDto getToken(String tokenValue, String tokenType) {
        String key = buildKey(tokenType, tokenValue);
        Object value = redisTemplate.opsForValue().get(key);
        if (value instanceof StoredTokenDto dto) {
            return dto;
        }
        throw new AuthException(ApiResponseType.INVALID_TOKEN);
    }

    @Override
    public void deleteToken(String tokenValue, String tokenType) {
        redisTemplate.delete(buildKey(tokenType, tokenValue));
    }

    @Override
    public void saveTokenPair(TokenPairDto pair) {
        saveToken(pair.accessToken());
        saveToken(pair.refreshToken());

        // token 연관성 저장
        redisTemplate.opsForValue().set("access_to_refresh:" + pair.accessToken().tokenValue(), pair.refreshToken().tokenValue());
        redisTemplate.opsForValue().set("refresh_to_access:" + pair.refreshToken().tokenValue(), pair.accessToken().tokenValue());
    }

    @Override
    public void deleteTokenPair(String accessTokenValue, String refreshTokenValue) {
        deleteToken(accessTokenValue, "access");
        deleteToken(refreshTokenValue, "refresh");

        redisTemplate.delete("access_to_refresh:" + accessTokenValue);
        redisTemplate.delete("refresh_to_access:" + refreshTokenValue);
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\type\ApiResponseType.java
package mango.security.authorizationServer.type;

import lombok.Getter;

@Getter
public enum ApiResponseType {
    SUCCESS("200", "성공"),
    LOGIN_FAILED("400", "로그인 실패"),
    UNAUTHORIZED("401", "인증 실패"),
    FORBIDDEN("403", "접근 권한 없음"),
    USER_NOT_FOUND("404", "사용자를 찾을 수 없음"),
    CLIENT_NOT_FOUND("404", "등록되지 않은 클라이언트입니다."),
    CLIENT_ALREADY_CONSENTED("409", "이미 동의한 클라이언트입니다."),
    OUTDATED_TOKEN("419", "토큰 만료"),
    INVALID_REQUEST("422", "잘못된 요청입니다."),
    CLIENT_ID_REQUIRED("422", "client_id는 필수입니다."),
    PRINCIPAL_NAME_REQUIRED("422", "principal_name은 필수입니다."),
    SCOPE_REQUIRED("422", "scope는 필수입니다."),
    REFRESH_TOKEN_EXPIRED("440", "리프레시 토큰 만료"),
    INVALID_TOKEN("498", "유효하지 않은 토큰"),
    REFRESH_TOKEN_INVALID("499", "유효하지 않은 리프레시 토큰"),
    ERROR("500", "서버 오류"),
    REDIS_CONNECTION_FAILED("503", "Redis 연결에 실패했습니다.");

    private final String status;
    private final String message;

    ApiResponseType(String status, String message) {
        this.status = status;
        this.message = message;
    }
}


C:\Users\tom99\study-security\authorization-server\src\main\java\mango\security\authorizationServer\util\Assert.java
package mango.security.authorizationServer.util;

import mango.security.authorizationServer.exception.AuthException;
import mango.security.authorizationServer.type.ApiResponseType;

import java.util.Collection;

public class Assert {

    public static void notBlank(String value, ApiResponseType type) {
        if (value == null || value.isBlank()) {
            throw new AuthException(type);
        }
    }

    public static void notNull(Object obj, ApiResponseType type) {
        if (obj == null) {
            throw new AuthException(type);
        }
    }

    public static void notEmpty(Collection<?> collection, ApiResponseType type) {
        if (collection == null || collection.isEmpty()) {
            throw new AuthException(type);
        }
    }

    public static void isTrue(boolean expression, ApiResponseType type) {
        if (!expression) {
            throw new AuthException(type);
        }
    }

    public static void isFalse(boolean expression, ApiResponseType type) {
        if (expression) {
            throw new AuthException(type);
        }
    }
}


