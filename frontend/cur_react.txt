
C:\Users\tom99\study-security\frontend\src\api\core\auth-server.ts
// src/api/core/auth-server.ts
import { createAxiosInstance } from './base'

const authServer = createAxiosInstance('http://localhost:9000')

export default authServer


C:\Users\tom99\study-security\frontend\src\api\core\backend.ts
// src/api/core/backend.ts
import axios from 'axios' // axios 직접 사용으로 변경 (createAxiosInstance 불필요 시)
import Cookies from 'js-cookie'
import { oauthAuth } from '../auth-api' // oauthAuth 임포트

const backend = axios.create({
  baseURL: 'http://localhost:8080/api',
  timeout: 10000,
  withCredentials: true, // 쿠키 전송에 필요할 수 있음
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request 인터셉터: 요청 전에 Access Token 부착
backend.interceptors.request.use(
  config => {
    const token = Cookies.get('accessToken')
    if (token && !config.headers.Authorization) {
      // Authorization 헤더가 없을 때만 추가
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// Response 인터셉터: 401 에러 시 토큰 재발급 및 재시도
let isRefreshing = false // 재발급 중복 방지 플래그
let failedQueue: { resolve: (value: unknown) => void; reject: (reason?: any) => void; config: any } // 실패한 요청 큐

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error)
    } else {
      prom.config.headers['Authorization'] = 'Bearer ' + token
      prom.resolve(backend(prom.config)) // axios 인스턴스로 재요청
    }
  })
  failedQueue
}

backend.interceptors.response.use(
  response => response, // 성공 응답은 그대로 반환
  async error => {
    const originalRequest = error.config

    // 401 에러이고, 재시도 요청이 아니며, refresh token이 있을 경우
    if (error.response?.status === 401 && !originalRequest._retry && Cookies.get('refreshToken')) {
      if (isRefreshing) {
        // 이미 재발급 중이면 큐에 추가
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject, config: originalRequest })
        })
      }

      originalRequest._retry = true // 재시도 플래그 설정
      isRefreshing = true

      const refreshTokenValue = Cookies.get('refreshToken')

      try {
        if (!refreshTokenValue) throw new Error('No refresh token found')

        const { access_token: newAccessToken, refresh_token: newRefreshToken } =
          await oauthAuth.refreshToken(refreshTokenValue)

        // 새 Access Token 쿠키 저장 (만료 시간은 서버 응답에 따라 설정해야 하나, 여기서는 간단히 설정)
        // 실제로는 expires_in 값을 받아 계산해야 함
        Cookies.set('accessToken', newAccessToken, { secure: true, sameSite: 'lax' })
        if (newRefreshToken) {
          // 새 Refresh Token이 발급된 경우 업데이트
          Cookies.set('refreshToken', newRefreshToken, {
            expires: 7,
            secure: true,
            sameSite: 'strict',
          })
        }

        console.log('Token refreshed successfully.')
        backend.defaults.headers.common['Authorization'] = 'Bearer ' + newAccessToken // axios 인스턴스 기본 헤더 업데이트
        originalRequest.headers['Authorization'] = 'Bearer ' + newAccessToken // 현재 요청 헤더 업데이트

        processQueue(null, newAccessToken) // 큐에 있던 요청들 처리
        return backend(originalRequest) // 원래 요청 재시도
      } catch (refreshError) {
        console.error('Unable to refresh token:', refreshError)
        // Refresh 실패 시 로그아웃 처리
        Cookies.remove('accessToken')
        Cookies.remove('refreshToken')
        processQueue(refreshError, null) // 큐에 있던 요청들 실패 처리
        // 로그인 페이지로 리디렉션 또는 에러 상태 관리
        // window.location.href = '/'; // 예시: 랜딩 페이지로 강제 이동
        return Promise.reject(refreshError)
      } finally {
        isRefreshing = false
      }
    }

    return Promise.reject(error) // 그 외 에러는 그대로 반환
  }
)

export default backend


C:\Users\tom99\study-security\frontend\src\api\core\base.ts
// src/api/core/base.ts
import axios, { AxiosInstance } from 'axios'

export const createAxiosInstance = (baseURL: string): AxiosInstance => {
  return axios.create({
    baseURL,
    timeout: 10000,
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
    },
  })
}


C:\Users\tom99\study-security\frontend\src\api\core\http.ts
// src/api/core/http.ts
import { AxiosInstance, Method, AxiosRequestConfig } from 'axios'

export const createApiMethod =
  (instance: AxiosInstance, method: Method) =>
  <T>(config: AxiosRequestConfig): Promise<T> =>
    instance({ ...config, method }).then(res => res.data)

export const createHttpClient = (instance: AxiosInstance) => ({
  get: createApiMethod(instance, 'GET'),
  post: createApiMethod(instance, 'POST'),
  put: createApiMethod(instance, 'PUT'),
  patch: createApiMethod(instance, 'PATCH'),
  delete: createApiMethod(instance, 'DELETE'),
})


C:\Users\tom99\study-security\frontend\src\api\core\index.ts
// src/api/core/index.ts
export * from './http'
export { default as authServer } from './auth-server'
export { default as backend } from './backend'
export * from './base'


C:\Users\tom99\study-security\frontend\src\api\auth-api.ts
// src/api/auth-api.ts
import { createHttpClient, backend /*, authServer */ } from './core'
import Cookies from 'js-cookie'

// Axios 인스턴스 생성 (기존 코드 활용)
const backendHttp = createHttpClient(backend)
// authServer 인스턴스는 /oauth2/token 엔드포인트 호출 시 Content-Type이 다르므로
// OauthCallback에서 직접 axios를 사용하거나 별도 설정된 인스턴스를 사용합니다.
// const oauthHttp = createHttpClient(authServer)

interface AuthResponse {
  // JPA/InMemory용 인터페이스 (OAuth에서는 직접 사용 안 함)
  accessToken: string
  refreshToken: string
}

// JPA 기반 인증 API 모듈 (OAuth와 별개)
export const jpaAuth = {
  login: (email: string, password: string) =>
    backendHttp.post<AuthResponse>({ url: '/auth/jpa/login', data: { email, password } }),
  // ... (signup, logout 등)
}

// InMemory 기반 인증 API 모듈 (OAuth와 별개)
export const inMemoryAuth = {
  login: (email: string, password: string) =>
    backendHttp.post<AuthResponse>({ url: '/auth/inmemory/login', data: { email, password } }),
  // ... (signup, logout 등)
}

// OAuth 관련 API
export const oauthAuth = {
  // 로그인 시작: Authorization Server로 리디렉션
  login: () => {
    // !! 중요: client_id와 redirect_uri를 서버 설정과 일치시킵니다.
    const clientId = 'oidc-client'
    const redirectUri = 'http://localhost:5173/oauth/callback'
    const authorizeUrl = `http://localhost:9000/oauth2/authorize?response_type=code&client_id=${clientId}&scope=openid%20profile%20message.read&redirect_uri=${redirectUri}`
    // TODO: PKCE 파라미터(code_challenge, code_challenge_method) 추가 권장

    window.location.href = authorizeUrl
  },
  // 회원가입도 동일한 OAuth 흐름을 따릅니다 (Auth Server에서 처리).
  signup: () => {
    oauthAuth.login()
  },
  // 로그아웃: 클라이언트 측 토큰 제거 및 상태 초기화
  logout: async () => {
    // 실제로는 Authorization Server의 로그아웃 엔드포인트 호출/리디렉션 필요할 수 있음
    // 예: window.location.href = 'http://localhost:9000/logout?id_token_hint=...&post_logout_redirect_uri=...'
    Cookies.remove('accessToken')
    Cookies.remove('refreshToken')
    // TODO: 서버 세션 무효화 또는 토큰 폐기 API 호출 (필요시)
    console.log('OAuth logout initiated (client-side token removal)')
    return Promise.resolve()
  },
  // 토큰 새로고침 함수 (backend 인터셉터 내부에서 사용됨)
  refreshToken: async (
    refreshTokenValue: string
  ): Promise<{ access_token: string; refresh_token?: string }> => {
    const clientId = 'oidc-client'
    const clientSecret = 'secret' // 실제 앱에서는 노출되면 안됨!

    const params = new URLSearchParams()
    params.append('grant_type', 'refresh_token')
    params.append('refresh_token', refreshTokenValue)

    const response = await fetch('http://localhost:9000/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: 'Basic ' + btoa(`${clientId}:${clientSecret}`), // Basic Auth
      },
      body: params,
    })

    if (!response.ok) {
      throw new Error(`Token refresh failed: ${response.statusText}`)
    }

    return response.json()
  },
}


C:\Users\tom99\study-security\frontend\src\components\Nav.tsx
// src/components/Nav.tsx
import { Link, useLocation, useNavigate } from 'react-router-dom'
import { useEffect, useState } from 'react'
import { useLoginType } from '../hooks/useLoginType'
import securityIcon from '../assets/spring-security.svg'

export default function Nav() {
  const location = useLocation()
  const [isLoggedIn, setIsLoggedIn] = useState(false)
  const navigate = useNavigate()
  const loginType = useLoginType()

  const navigateToHome = () => {
    navigate('/home')
  }

  useEffect(() => {
    setIsLoggedIn(location.pathname === '/home')
  }, [location])

  return (
    <nav className="fixed top-0 right-0 left-0 z-10 bg-stone-700 shadow-md">
      <div className="container mx-auto flex items-center justify-between p-4">
        <div className="flex items-center space-x-3" onClick={navigateToHome}>
          <div className="h-12 w-12">
            <img src={securityIcon} alt="Spring Security Logo" className="neon-svg" />
          </div>
          <div className="text-4xl font-bold">
            <span className="neon-spring">Spring</span>
            <span className="neon-security"> Security</span>
          </div>
        </div>
        <div className="flex space-x-4">
          {isLoggedIn ? (
            <>
              <Link
                to="/home"
                className={`transition-colors hover:text-[#00FF80] ${location.pathname === '/home' ? 'text-[#00FF80]' : ''}`}
              >
                Home
              </Link>
              <Link to="/logout" className="transition-colors hover:text-[#00FF80]">
                Logout
              </Link>
            </>
          ) : (
            <>
              {/* 로그인 페이지 링크는 현재 로그인 타입에 따라 다르게 지정 */}
              <Link
                to={
                  loginType === 'JPA'
                    ? '/jpa/login'
                    : loginType === 'OAuth'
                      ? '/oauth/login'
                      : '/inmemory/login'
                }
                className={`transition-colors hover:text-[#00FF80] ${location.pathname.endsWith('login') ? 'text-[#00FF80]' : ''}`}
              >
                Login
              </Link>
              <Link
                to="/signup"
                className={`transition-colors hover:text-[#00FF80] ${location.pathname === '/signup' ? 'text-[#00FF80]' : ''}`}
              >
                Signup
              </Link>
            </>
          )}
        </div>
      </div>
    </nav>
  )
}


C:\Users\tom99\study-security\frontend\src\components\NeonTwinGlowBox.tsx
// import React from 'react'

// export default function NeonTwinGlowBox() {
//   return (
//     <div className="relative flex h-12 w-48 items-center justify-center rounded-md bg-black">
//       <svg
//         className="pointer-events-none absolute top-0 left-0 h-full w-full"
//         viewBox="0 0 100 100"
//         preserveAspectRatio="none"
//       >
//         {/* 하단 중앙에서 시작해서 왼쪽으로 돌고 상단 중앙에서 끝나는 경로 */}
//         <path
//           d="M 50,99 L 1,99 L 1,1 L 50,1"
//           fill="none"
//           stroke="#00ffe1"
//           strokeWidth="1.5"
//           pathLength="1"
//           strokeDasharray="0.025 0.975"
//           strokeDashoffset="1"
//           className="glow-one"
//         />

//         {/* 하단 중앙에서 시작해서 오른쪽으로 돌고 상단 중앙에서 끝나는 경로 */}
//         <path
//           d="M 50,99 L 99,99 L 99,1 L 50,1"
//           fill="none"
//           stroke="#00ffe1"
//           strokeWidth="1.5"
//           pathLength="1"
//           strokeDasharray="0.025 0.975"
//           strokeDashoffset="1"
//           className="glow-two"
//         />
//       </svg>
//       <div className="z-10 font-bold text-white">LOGO</div>
//     </div>
//   )
// }

import React from 'react';

export default function NeonTwinGlowBox() {
  return (
    <div className="relative flex h-12 w-48 items-center justify-center rounded-md bg-black">
      <svg
        className="pointer-events-none absolute top-0 left-0 h-full w-full"
        viewBox="0 0 100 100"
        preserveAspectRatio="none"
      >
        {/* 하단 중앙에서 시작해서 왼쪽으로 돌고 상단 중앙에서 끝나는 경로 */}
        <path
          d="M 50,99 L 1,99 L 1,1 L 50,1"
          fill="none"
          stroke="#00ffe1"
          strokeWidth="1.5"
          pathLength="1" 
          strokeDasharray="0.025 0.975"
          strokeDashoffset="1"
          className="glow-one"
        />

        {/* 하단 중앙에서 시작해서 오른쪽으로 돌고 상단 중앙에서 끝나는 경로 */}
        <path
          d="M 50,99 L 99,99 L 99,1 L 50,1"
          fill="none"
          stroke="#00ffe1"
          strokeWidth="1.5"
          pathLength="1"
          strokeDasharray="0.025 0.975"
          strokeDashoffset="1"
          className="glow-two"
        />
      </svg>
      <div className="z-10 font-bold text-white">LOGO</div>
    </div>
  )
}

C:\Users\tom99\study-security\frontend\src\components\ProtectedRoute.tsx
// src/components/ProtectedRoute.tsx
import { Navigate, Outlet } from 'react-router-dom'
import { useAuthContext } from '../context/auth' // useAuthContext 사용

export default function ProtectedRoute() {
  const { isAuthenticated } = useAuthContext() // AuthContext에서 상태 가져오기

  // console.log('ProtectedRoute check:', isAuthenticated); // 디버깅용

  return isAuthenticated ? <Outlet /> : <Navigate to="/" replace />
}


C:\Users\tom99\study-security\frontend\src\context\auth.tsx
// src/context/auth.tsx
import React, { createContext, useContext, useEffect, useState, useCallback } from 'react'
import Cookies from 'js-cookie'
import { useLoginType } from '../hooks/useLoginType'
import { jpaAuth, inMemoryAuth, oauthAuth } from '../api/auth-api'
import backend from '../api/core/backend' // backend 인스턴스 직접 임포트

interface AuthContextType {
  isAuthenticated: boolean
  checkAuth: () => Promise<void> // 인증 상태 확인 함수 추가
  login: (email: string, password: string) => Promise<void> // JPA/InMemory 용
  signup: (email: string, password: string) => Promise<void> // JPA/InMemory 용
  logout: () => Promise<void>
  isLoading: boolean // 로딩 상태 추가
}

const AuthContext = createContext<AuthContextType>({
  isAuthenticated: false,
  checkAuth: async () => {},
  login: async () => {},
  signup: async () => {},
  logout: async () => {},
  isLoading: true, // 초기 로딩 상태 true
})

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [isLoading, setIsLoading] = useState(true) // 로딩 상태
  const loginType = useLoginType() // 현재 경로 기반 로그인 타입

  // 현재 타입에 맞는 API 모듈 선택 (JPA/InMemory는 예시)
  const getAuthApi = useCallback(
    () => {
      // 현재 프로젝트에서는 OAuth만 사용하므로 oauthAuth만 고려
      // 실제로는 loginType에 따라 분기
      return oauthAuth
      // if (loginType === 'JPA') return jpaAuth;
      // if (loginType === 'OAuth') return oauthAuth;
      // return inMemoryAuth;
    },
    [
      /* loginType */
    ]
  ) // loginType이 변경될 때마다 API 객체 다시 가져옴

  // 인증 상태 확인 로직
  const checkAuth = useCallback(async () => {
    setIsLoading(true)
    const token = Cookies.get('accessToken')
    if (token) {
      try {
        await backend.get('/messages')
        setIsAuthenticated(true)
        console.log('✅ User is authenticated via token check.')
      } catch (error) {
        console.error('❌ Token validation failed:', error)
        setIsAuthenticated(false)
      }
    } else {
      console.log('❌ No access token found.')
      setIsAuthenticated(false)
    }
    setIsLoading(false)
  }, [])

  useEffect(() => {
    checkAuth()
  }, [checkAuth]) // 이제 checkAuth는 변하지 않으므로 useEffect는 앱 로드시 한 번만 실행됩니다.

  // 앱 로드 시 인증 상태 확인
  useEffect(() => {
    checkAuth()
  }, [checkAuth])

  // JPA/InMemory 로그인 (OAuth와는 별개)
  const login = async (email: string, password: string) => {
    // const api = getAuthApi();
    // if (api === oauthAuth) {
    //   console.warn("OAuth login is initiated via redirect, not this function.");
    //   return;
    // }
    // await api.login(email, password); // JPA 또는 InMemory API 호출
    // await checkAuth(); // 로그인 성공 후 상태 재확인
    console.warn('JPA/InMemory login not implemented in this context')
  }

  // JPA/InMemory 회원가입 (OAuth와는 별개)
  const signup = async (email: string, password: string) => {
    // const api = getAuthApi();
    // if (api === oauthAuth) {
    //    console.warn("OAuth signup is handled by the Authorization Server.");
    //    return;
    // }
    // await api.signup(email, password); // JPA 또는 InMemory API 호출
    // await checkAuth(); // 가입 성공 후 상태 재확인 (자동 로그인 시)
    console.warn('JPA/InMemory signup not implemented in this context')
  }

  // 로그아웃
  const logout = async () => {
    const api = getAuthApi()
    try {
      await api.logout() // API 호출 (클라이언트 측 토큰 제거 포함)
    } catch (error) {
      console.error('Logout API call failed:', error)
      // API 호출 실패해도 클라이언트 측 토큰은 제거
      Cookies.remove('accessToken')
      Cookies.remove('refreshToken')
    } finally {
      setIsAuthenticated(false) // 상태 업데이트
    }
  }

  return (
    <AuthContext.Provider value={{ isAuthenticated, checkAuth, login, signup, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  )
}

// useAuthContext 훅 이름 변경 방지 위해 그대로 둠
export const useAuthContext = () => useContext(AuthContext)

// useAuth 훅은 API 객체 직접 반환하므로 이름 유지
export const useAuth = () => {
  const loginType = useLoginType()
  if (loginType === 'JPA') return jpaAuth
  if (loginType === 'OAuth') return oauthAuth
  return inMemoryAuth
}


C:\Users\tom99\study-security\frontend\src\hooks\useAuth.ts
// src/hooks/useAuth.ts
import { useLoginType } from './useLoginType'
import { jpaAuth, inMemoryAuth, oauthAuth } from '../api/auth-api'

export const useAuth = () => {
  const loginType = useLoginType()
  if (loginType === 'JPA') return jpaAuth
  if (loginType === 'OAuth') return oauthAuth
  return inMemoryAuth
}


C:\Users\tom99\study-security\frontend\src\hooks\useLoginType.ts
// src/hooks/useLoginType.ts
import { useLocation } from 'react-router-dom'

export const useLoginType = (): 'JPA' | 'OAuth' | 'InMemory' => {
  const location = useLocation()
  if (location.pathname.startsWith('/jpa')) return 'JPA'
  if (location.pathname.startsWith('/oauth')) return 'OAuth'
  return 'InMemory'
}
  

C:\Users\tom99\study-security\frontend\src\pages\Home.tsx
import { useNavigate } from 'react-router-dom'
import { useAuth } from '../hooks/useAuth'
import { useLoginType } from '../hooks/useLoginType'

export default function Home() {
  const navigate = useNavigate()
  const auth = useAuth()
  const loginType = useLoginType()

  const handleLogout = async () => {
    try {
      await auth.logout()
      navigate('/')
    } catch (err) {
      console.error('Logout failed', err)
    }
  }

  return (
    <div className="flex h-screen items-center justify-center">
      <div className="form-container text-center">
        <h1 className="mb-4 text-2xl font-bold">Welcome Home ({loginType})</h1>
        <p className="mb-6">This is your home page.</p>
        <button onClick={handleLogout} className="btn">
          Logout
        </button>
      </div>
    </div>
  )
}


C:\Users\tom99\study-security\frontend\src\pages\index.ts
export { default as Home } from './Home.tsx'
export { default as Login } from './Login.tsx'
export { default as Signup } from './Signup.tsx'
export { default as OauthCallback } from './OauthCallback.tsx'
export { default as LandingPage } from './LandingPage.tsx'


C:\Users\tom99\study-security\frontend\src\pages\LandingPage.tsx
// src/pages/LandingPage.tsx
import { useNavigate } from 'react-router-dom'
import { oauthAuth } from '../api/auth-api' // oauthAuth 임포트

export default function LandingPage() {
  const navigate = useNavigate()

  const goToLogin = (mode: 'inmemory' | 'jpa') => {
    // oauth 제외
    if (mode === 'inmemory') {
      navigate('/inmemory/login')
    } else if (mode === 'jpa') {
      navigate('/jpa/login')
    }
  }

  const handleOAuthLogin = () => {
    oauthAuth.login() // 바로 리디렉션 시작
  }

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-100">
      <h1 className="mb-6 text-4xl font-bold">Welcome to the Auth Demo</h1>
      <p className="mb-8 text-lg">아래 버튼을 눌러 원하는 인증 방식을 선택하세요.</p>
      <div className="flex flex-col space-y-4">
        {/* ... InMemory, JPA 버튼은 그대로 ... */}
        <button
          onClick={() => goToLogin('inmemory')}
          className="rounded bg-blue-500 px-6 py-3 text-white hover:bg-blue-600"
        >
          InMemory 로그인
        </button>
        <button
          onClick={() => goToLogin('jpa')}
          className="rounded bg-green-500 px-6 py-3 text-white hover:bg-green-600"
        >
          JPA (Redis) 로그인
        </button>
        {/* OAuth 로그인 버튼 수정 */}
        <button
          onClick={handleOAuthLogin} // oauthAuth.login 호출
          className="rounded bg-purple-500 px-6 py-3 text-white hover:bg-purple-600"
        >
          OAuth 로그인
        </button>
      </div>
    </div>
  )
}


C:\Users\tom99\study-security\frontend\src\pages\Login.tsx
// src/pages/Login.tsx
import { useState } from 'react'
import { useNavigate, Link } from 'react-router-dom'
import { useAuth } from '../hooks/useAuth'
import { useLoginType } from '../hooks/useLoginType'

export default function Login() {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')
  const navigate = useNavigate()
  const auth = useAuth()
  const loginType = useLoginType()

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    try {
      await auth.login(username, password)
      navigate('/home')
    } catch (err) {
      console.error('Login failed', err)
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center">
      <form onSubmit={handleLogin} className="form-container">
        <h1 className="mb-2 text-xl font-semibold">Login ({loginType})</h1>
        <input
          type="text"
          placeholder="Username"
          className="input mb-2"
          value={username}
          onChange={e => setUsername(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          className="input mb-4"
          value={password}
          onChange={e => setPassword(e.target.value)}
        />
        <button type="submit" className="btn">
          Login
        </button>
        <div className="mt-4 text-center text-sm">
          Don't have an account?{' '}
          <Link to="/signup" className="text-[var(--color-primary)]">
            Sign up
          </Link>
        </div>
      </form>
    </div>
  )
}


C:\Users\tom99\study-security\frontend\src\pages\OauthCallback.tsx
// src/pages/OauthCallback.tsx
import { useAuthContext } from '../context/auth'
import { useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import Cookies from 'js-cookie'

export default function OauthCallback() {
  const navigate = useNavigate()
  const { checkAuth } = useAuthContext()

  useEffect(() => {
    const exchangeCodeForToken = async () => {
      const code = new URLSearchParams(window.location.search).get('code')
      if (!code) {
        console.error('No authorization code found in callback URL.')
        navigate('/') // 오류 발생 시 랜딩 페이지로 이동
        return
      }

      const clientId = 'oidc-client' // 서버와 일치
      const clientSecret = 'secret' // 서버와 일치 (주의: 실제 앱에서는 노출 금지!)
      const redirectUri = 'http://localhost:5173/oauth/callback' // 서버와 일치

      // URLSearchParams를 사용하여 x-www-form-urlencoded 형식 데이터 준비
      const params = new URLSearchParams()
      params.append('grant_type', 'authorization_code')
      params.append('code', code)
      params.append('redirect_uri', redirectUri)
      // PKCE 사용 시 code_verifier 파라미터 추가 필요
      // params.append('code_verifier', 'YOUR_CODE_VERIFIER_STORED_IN_SESSION_OR_LOCALSTORAGE');

      try {
        const response = await fetch('http://localhost:9000/oauth2/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Authorization: 'Basic ' + btoa(`${clientId}:${clientSecret}`), // Basic Authentication
          },
          body: params,
        })

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({})) // 오류 응답 파싱 시도
          console.error('Token exchange failed:', response.status, response.statusText, errorData)
          throw new Error(`Token exchange failed: ${response.status}`)
        }

        const tokens = await response.json()
        const { access_token, refresh_token, expires_in } = tokens

        if (!access_token) {
          throw new Error('Access token not received')
        }

        // 쿠키에 토큰 저장 (js-cookie 사용)
        // 만료 시간 설정 (expires_in은 초 단위)
        const expiryDate = new Date(new Date().getTime() + expires_in * 1000)
        Cookies.set('accessToken', access_token, {
          expires: expiryDate,
          secure: true,
          sameSite: 'lax',
        }) // HTTPS에서만 전송, Lax 권장
        if (refresh_token) {
          // Refresh token은 더 긴 만료 시간 설정 가능 (예: 7일)
          Cookies.set('refreshToken', refresh_token, {
            expires: 7,
            secure: true,
            sameSite: 'strict',
          }) // Strict 권장
        }

        console.log('Tokens obtained and stored in cookies.')

        await checkAuth()

        navigate('/home') // 성공 시 홈으로 이동
      } catch (err) {
        console.error('Error during token exchange:', err)
        // 사용자에게 오류 메시지 표시 또는 오류 페이지로 리디렉션
        navigate('/') // 오류 시 랜딩 페이지로 이동
      }
    }

    exchangeCodeForToken()
  }, [navigate, checkAuth])

  return (
    <div className="flex h-screen items-center justify-center">Processing OAuth callback...</div>
  )
}


C:\Users\tom99\study-security\frontend\src\pages\Signup.tsx
// src/pages/Signup.tsx
import { useState } from 'react'
import { useNavigate, Link } from 'react-router-dom'
import { useAuthContext } from '../context/auth'
import { useLoginType } from '../hooks/useLoginType'

export default function Signup() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const navigate = useNavigate()
  const { signup } = useAuthContext()
  const loginType = useLoginType()

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault()
    try {
      await signup(email, password)
      // 가입 후 랜딩 페이지(혹은 홈)으로 이동
      navigate('/home')
    } catch (err) {
      console.error('Signup failed', err)
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-[var(--color-bg-light)] dark:bg-[var(--color-bg-dark)]">
      <form onSubmit={handleSignup} className="form-container">
        <h1 className="mb-4 text-2xl font-bold">Sign Up ({loginType})</h1>
        <input
          className="input mb-3"
          type="email"
          placeholder="Email"
          value={email}
          onChange={e => setEmail(e.target.value)}
        />
        <input
          className="input mb-4"
          type="password"
          placeholder="Password"
          value={password}
          onChange={e => setPassword(e.target.value)}
        />
        <button className="btn" type="submit">
          Sign Up
        </button>
        <div className="mt-4 text-center text-sm">
          Already have an account?{' '}
          <Link to="/" className="text-[var(--color-primary)]">
            Login
          </Link>
        </div>
      </form>
    </div>
  )
}


C:\Users\tom99\study-security\frontend\src\App.tsx
// src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import Nav from './components/Nav'
import { AuthProvider, useAuthContext } from './context/auth'
import { Home, Login, Signup, OauthCallback, LandingPage } from './pages'
import ProtectedRoute from './components/ProtectedRoute' // ProtectedRoute 임포트

function AppContent() {
  const { isLoading } = useAuthContext()

  if (isLoading) {
    return <div className="flex h-screen items-center justify-center">Loading...</div> // 로딩 상태 표시
  }

  return (
    <div className="flex min-h-screen flex-col">
      <Nav />
      <main className="mt-16 flex-grow">
        <Routes>
          {/* 기본 랜딩 페이지 */}
          <Route path="/" element={<LandingPage />} />

          {/* JPA/InMemory 로그인/회원가입 경로 (OAuth와 별개) */}
          <Route path="/inmemory/login" element={<Login />} />
          <Route path="/jpa/login" element={<Login />} />
          {/* 공용 회원가입 경로는 유지 */}
          <Route path="/signup" element={<Signup />} />

          {/* 보호된 경로 */}
          <Route element={<ProtectedRoute />}>
            <Route path="/home" element={<Home />} />
            {/* 다른 보호된 경로 추가 가능 */}
          </Route>

          {/* OAuth 콜백 경로 */}
          <Route path="/oauth/callback" element={<OauthCallback />} />

          {/* 다른 경로들... */}
        </Routes>
      </main>
    </div>
  )
}

export default function App() {
  return (
    <BrowserRouter>
      <AuthProvider>
        <AppContent />
      </AuthProvider>
    </BrowserRouter>
  )
}


C:\Users\tom99\study-security\frontend\src\main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
)


C:\Users\tom99\study-security\frontend\src\vite-env.d.ts
/// <reference types="vite/client" />

